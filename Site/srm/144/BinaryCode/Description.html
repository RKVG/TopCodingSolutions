<div style="margin-top:0px;margin-bottom:5px;font-size:18px;font-weight:bold;text-decoration:underline">Problem:</div>
<a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=1704" target="_blank">SRM 144 DIV 1 - 300</a>


<div style="margin-top:20px;margin-bottom:5px;font-size:18px;font-weight:bold;text-decoration:underline">Overview:</div>
You are asked to decode a string. The original String is in binary format. The encoded string is formed by adding both neighboring digits to the current digit.


<div style="margin-top:20px;margin-bottom:5px;font-size:18px;font-weight:bold;text-decoration:underline">Java Source:</div>
<pre style="font-family:Courier New,Courier,monospace;font-size:14px;padding:20px;text-align:left;width:100%">
<font color="#00FF00">
    01: public class BinaryCode {
    02:
    03:     /*
    04:     Decodes the string.
    05:     The string is encoded by adding it's two neighbors to it's values.
    06:     So:
    07:     1001001 becomes 1111111
    08:     In some cases the message may decode to two different values depending on
    09:     if pos1 = 0 or 1.
    10:     In other cases a value of 0 or 1 may lead to a message that cannot be decoded.
    11:     i.e. would require a a digit other than 0 or 1 to make the sums add up.
    12:      */
    13:     private static String decode(char[] message, char pos1) {
    14:
    15:         /*
    16:         Create a return array that is 1 element larger than the message.  This extra
    17:         space will make it easier to compute the last element, and will ultimately
    18:         get chopped off before returning anyway.
    19:          */
    20:         char[] ret = new char[message.length + 1];
    21:
    22:         // Set the first position to either a 0 or 1 depending on the parameter.
    23:         ret[0] = pos1;
    24:
    25:         // Loop through the return array starting at position 1.
    26:         for (int i = 1; i < ret.length; i++) {
    27:             Integer a = Integer.parseInt("" + message[i - 1]);
    28:             Integer b = Integer.parseInt("" + ret[i - 1]);
    29:
    30:             // This protects from going in front of the beginning of the array.
    31:             Integer c = (i == 1) ? 0 : Integer.parseInt("" + ret[i - 2]);
    32:
    33:             /*
    34:             The current value in the return array will equal:
    35:             (one position back in the message) - (one position back in the return array) -
    36:             (2 positions back in the return array)
    37:             Write this out on papers until you're convinced that it works.
    38:              */
    39:             int val = a - b - c;
    40:
    41:             // If we arrive at a non-binary digit, then the encoding was impossible given the value of pos1.
    42:             if ((val > 1) || (val < 0)) {
    43:                 return "NONE";
    44:             }
    45:
    46:             // Convert the number to a character.
    47:             ret[i] = (char) (val + '0');
    48:         }
    49:
    50:         // Convert the array to a String, and chop off the last place.
    51:         return new String(ret).substring(0, ret.length - 1);
    52:     }
    53:
    54:     public String[] decode(String message) {
    55:
    56:         // Create an array of Strings to return.
    57:         String[] ret = new String[2];
    58:
    59:         // Populate the return array with the results of decoding.
    60:         // First when we assume that the first digit was a 0.
    61:         // Then when we assume the first digit was a 1.
    62:         ret[0] = decode(message.toCharArray(), '0');
    63:         ret[1] = decode(message.toCharArray(), '1');
    64:
    65:         return ret;
    66:     }
    67: }
</font>
</pre>

<div style="margin-top:20px;margin-bottom:5px;font-size:18px;font-weight:bold;text-decoration:underline">Notes:</div>
<p>
    The toughest part of this problem is determining how to calculate the
    value at the current location of the return String, line 62. I suggest
    you write this out on paper to see how it works. For example:
</p>

<table>
<tbody>
<tr>
<td>message:</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>return:</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>?</td>
</tr>
</tbody>
</table>

<p>
    The value of the ? will be one space back in the message array (3) -
    one space back in the return array (1) - two spaces back in the
    return array (1). 3 - 1 - 1 = 1. These values are calculated on lines
    50, 51, and 54.
</p>
<p>
    If you insert 1 for the ?, you'll see that the encoding/decoding of
    the message is correct up to that point.
</p>
<p>
    The next position in the return array must be 0, since the 2 is already
    the total the 1 (at the ? location) and 1 (one space before the ?).
</p>

<div style="margin-top:50px;text-align:center;font-size:14px">
<p><i>Thank you</i> for taking the time to read this solution.  I welcome any feedback you may have.</p>
<p>Please post any questions or comments <a href="http://blog.topcodingsolutions.net/2014/06/srm-144-div-1-300-points-srm-144-div-2.html" target="_blank">here</a>.</p>
<p>For this, and other TopCoder solutions, please visit <a href="http://www.topcodingsolutions.net" target="_blank">www.topcodingsolutions.net</a>.</p>
</div>
