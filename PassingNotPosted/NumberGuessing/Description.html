<div style="margin-top:0px;margin-bottom:5px;font-size:18px;font-weight:bold;text-decoration:underline">
    Problem Statement:
</div>
<a href="http://community.topcoder.com/stat?c=problem_statement&pm=1747"
   target="_blank">SRM 148 DIV 1 - 1100 Points</a>

<div style="margin-top:20px;margin-bottom:5px;font-size:18px;font-weight:bold;text-decoration:underline">
    Overview:
</div>
<p>
    Choose the best number in a guessing game.
</p>


<div style="margin-top:20px;margin-bottom:5px;font-size:18px;font-weight:bold;text-decoration:underline">
    Java Source:
</div>
<pre style="background:#000000;color:#fdbb30;font-family:Courier New,Courier,monospace;font-size:14px;height:auto;line-height:20px;overflow:auto;padding:20px;text-align:left;width:95%">
001: import java.util.Arrays;
002: import java.util.HashSet;
003: import java.util.Set;
004: 
005: public class NumberGuessing {
006: 
007:     /*
008:      * Returns a set of all Integers that should be tried.  If there are no
009:      * guesses to follow, then the set will be:
010:      * 1 less than the smallest guess.
011:      * 1 greater than all previous guesses.
012:      * If there are more guesses to follow, then return all integers in the
013:      * range.
014:      * In either case, do not add any numbers that already appear in guesses.
015:      */
016:     public static Set<Integer> getPossibleGuesses(int range, int[] guesses,
017:                                                   boolean isLast) {
018: 
019:         Set<Integer> possibleGuesses = new HashSet<>();
020: 
021:         if (isLast) {
022: 
023:             // If there are no guesses, and no guesses to follow, just return 1
024:             if (guesses.length == 0) {
025:                 possibleGuesses.add(1);
026:                 return possibleGuesses;
027: 
028:                 /*
029:                 * If there are guesses to follow, return one less than the
030:                 * smallest guess, and one greater than all other guesses.
031:                 * Be sure to check that we're not adding < 1 or > range.
032:                 */
033:             } else {
034:                 if (guesses[0] > 1) {
035:                     possibleGuesses.add(guesses[0] - 1);
036:                 }
037: 
038:                 for (int g : guesses) {
039:                     if (g < range) {
040:                         possibleGuesses.add(g + 1);
041:                     }
042:                 }
043:             }
044: 
045:             /*
046:              * If there are guesses to follow, then we'll check every number
047:              * in the range that hasn't alredy been guesses.
048:              */
049:         } else {
050:             for (int i = 1; i <= range; i++) {
051:                 possibleGuesses.add(i);
052:             }
053:         }
054: 
055:         for (int i : guesses) {
056:             possibleGuesses.remove(i);
057:         }
058: 
059:         return possibleGuesses;
060:     }
061: 
062:     /*
063:      * Makes the best guess possible based on the guesses that have been taken,
064:      * and the number of guesses to follow.  Returns an array that equals
065:      * guesses, except that the new best guess is inserted.
066:      * The best guess is obtained by following these steps.
067:      * 1. Obtain possible guesses.
068:      * 2. For each possible guess, call makeBestGuess recursively to get how
069:      * all the following guessers will respond.
070:      * 3. Check what the yield is for that guess (how many numbers = a win)
071:      * 4. Repeat for all other possible guesses, keeping track of the largest
072:      * yield.
073:      */
074:     public GuessResults makeBestGuess(int range, int[] guesses,
075:                                       int numLeft) {
076: 
077:         // When numLeft < 0, return to break the recursion.
078:         if (numLeft < 0) {
079:             return new GuessResults(guesses);
080:         }
081: 
082:         // Used to keep track of the best guess tried so far and it's result.
083:         int maxYield = 0;
084:         GuessResults maxResults = new GuessResults();
085: 
086:         Set<Integer> possibleGuesses = getPossibleGuesses(range, guesses,
087:                 (numLeft == 0));
088: 
089:         for (int possibleGuess : possibleGuesses) {
090: 
091:             /*
092:              * Make a copy of the guesses array, and insert the new guess into
093:              * its proper location.
094:              */
095:             int[] beforeTry = Arrays.copyOf(guesses, guesses.length + 1);
096:             beforeTry[beforeTry.length - 1] = possibleGuess;
097:             Arrays.sort(beforeTry);
098: 
099:             /*
100:              * Recursively call makeBestGuess() using this current guess and
101:              * check the results.
102:              */
103:             GuessResults afterTry = makeBestGuess(range, beforeTry,
104:                     numLeft - 1);
105:             afterTry.guess = possibleGuess;
106: 
107:             int yield = calculateYield(possibleGuess, afterTry.results, range);
108: 
109:             if ((yield > maxYield) ||
110:                     ((yield == maxYield) &&
111:                             (possibleGuess < maxResults.guess))) {
112:                 maxYield = yield;
113:                 maxResults = afterTry;
114:             }
115:         }
116: 
117:         return maxResults;
118:     }
119: 
120:     /*
121:      * Given an array of guesses, returns how many numbers result in a win
122:      * for the given guess.
123:      * The given guess must exist in the array of guesses.
124:      */
125:     public int calculateYield(int guess, int[] guesses, int range) {
126: 
127:         int yield;
128: 
129:         // Determine the position of guess in the array of guesses.
130:         int i = 0;
131:         while (guesses[i] != guess) {
132:             i++;
133:         }
134: 
135:         // This guess is the lowest.
136:         if (i == 0) {
137:             yield = guess + ((guesses[i + 1] - guess - 1) / 2);
138: 
139:             // This guess is the highest.
140:         } else if (i == (guesses.length - 1)) {
141:             yield = (range - guess + 1) + ((guess - guesses[i - 1] - 1) / 2);
142: 
143:             // This guess is somewhere in between two other guesses.
144:         } else {
145:             yield = (((guesses[i + 1] - guess - 1) / 2)
146:                     + 1 +
147:                     ((guess - guesses[i - 1] - 1) / 2));
148:         }
149: 
150:         return yield;
151:     }
152: 
153:     /*
154:      * Loops through all possible guesses to determine which one results in
155:      * the greatest yeild.
156:      */
157:     public int bestGuess(int range, int[] guesses, int numLeft) {
158: 
159:         // If there is only one number possible, take it and quit early.
160:         if (range == 1) {
161:             return 1;
162:         }
163: 
164:         return makeBestGuess(range, guesses, numLeft).guess;
165:     }
166: 
167:     /*
168:      * Ties a guess to the resulting array of guesses
169:      */
170:     private class GuessResults {
171:         int[] results;
172:         Integer guess;
173: 
174:         GuessResults() {
175:             this.results = null;
176:             this.guess = Integer.MAX_VALUE;
177:         }
178: 
179:         GuessResults(int[] results) {
180:             this.results = results;
181:             this.guess = Integer.MAX_VALUE;
182:         }
183:     }
184: }
</pre>

<div style="margin-top:20px;margin-bottom:5px;font-size:18px;font-weight:bold;text-decoration:underline">
    Notes:
</div>
<p>
    There's a lot of pitfalls waitng in this problem. I'll start with an
    overview of the solution, and then go into some of the mistakes that I
    made along the way.
</p>
<p>
    The solution first obtains a list of numbers that it should try. It's
    farily clear that if there are no guesses to follow, then your guess
    should either be 1 lower that the lowest guess, or 1 higher than a
    previous guess. Any number picked between two numbers will yield the
    same number of wins as any other number picked between those same two
    numbers, so it's sufficient just to try the lowest in any segment.
</p>
<p>
    The first problem comes up when trying to determine which numbers
    to pick when you're not that last to go. You might just pick numbers
    that are at the mid-point between two previous guesses.
    A more sophisticated approach
    might introduce the number of guesses to follow. So pick the 1/2 point,
    if there is one guess to follow. Pick 1/4 way points if there are two
    guesses to follow, etc. This will drive you nuts, and is ultimately
    unnecessary - maybe - see below.
</p>
<p>
    The specs limit the range and number of followers sufficiently so that
    you can use brute force on any guess that has followers. The numbers to
    try in this case are just all numbers that haven't been guessed
    previously.
</p>
<p>
    Armed with the list of number to try, we loop through each of them.
    First, we re-create the guesses[] array adding the current number that we're
    trying. Then we pass this new array, along with one less follower to
    makeBestGuess(). This returns an array containting all the responses
    from all the followers for that guess.
    Next, we check how many numbers will result in a win with that
    guess, and finally, store that guess and the results if it yielded more
    wins than anything previously seen.
</p>
<p>
    One thing that was more annoying than difficult is the fact that
    makeBestGuess() and bestGuess() require two different return values.
    makeBestGuess() needs an array of ints that represents all of the
    resulting guesses; while bestGuess() just need the guess itself. To
    solve this problem, and avoid a lot of duplicate code, I introduced the
    GuessResults inner class to tie the guess and it's response together.
</p>
<p>
    The final difficult part is in calculating the number of wins that a
    given guess yields. This is handled by the calculateYield() method. It
    expects an array containing all the guesses, both before and after our
    guess, as well as our guess and also the range. There are three separate
    equations: One if our guess is the lowest, one if it's the highest, and
    one if it falls between two other guesses. Care, and a lot of testing,
    are needed to get these right.
</p>
<p>
    As a final note, the longest running test in the TopCoder arena
    took 3.7 seconds to complete, which is greater than the 2 seconds
    they allow. However, on my machine, the same test ran in .4
    seconds, so I can live with it.
</p>
<p>
    I tried some optimizations, such as replacing the calls to Arrays.sort()
    with a customized sort that took advantage of the fact that
    there was only one number to add. These didn't add up to much. If I had
    to get that test down under 2 seconds, I'd need to revisit the
    getPossibleGuesses() method for guesses that had followers.
</p>
</div>

<div style="margin-top:50px;text-align:center;font-size:14px">
    <p><i>Thank you</i> for taking the time to read this solution. I welcome any
        feedback you may have.</p>

    <p>Please post any questions or comments <a
            href="LINK" target="_blank">here</a>.</p>

    <p>For this, and other TopCoder solutions, please visit <a
            href="http://www.topcodingsolutions.net" target="_blank">www.topcodingsolutions.net</a>.
    </p>
</div>
